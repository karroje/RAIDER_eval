# Analysize RM output in more detail.  Assuming only positive strand.
from perform_stats import *
import sys
import re
from Bio import SeqIO

class Rpt:
    def __init__(self, family, start, end, remain, strand):
        self.family = family;
        self.start = int(start);
        self.end = int(end);
        self.remain = int(remain)
        self.strand = str(strand)

    def __str__(self):
        return " ".join([self.family, str(self.start), str(self.end)])

    def __len__(self):
        return self.end - self.start


def repeat_bounds_generator(rep_file, exclusion_set=None):
    """ Generator function. Returns the start and end index of the next repeat.
    
    Keyword arguments:
    rep_file -- the repeat file generated by repeatmasker
    exclusion_set -- criteria for a repeat to be skipped
    """
    rf = open(rep_file, 'r')
    rf.readline()
    rf.readline()
    rf.readline()
    while True:
        line = rf.readline()
        if not line:
            break
        if line[0] == "#" or len(line) == 0:
            continue
        # if exclusion_set specified, check that should not exclude line
        if not exclusion_set or (exclusion_set and not any([s in line for s in exclusion_set])):
            A = re.split("\s+", line.strip())
            start = int(A[5]) - 1
            end = int(A[6])
            remain = int(A[7][1:-1])
            strand = A[7]
            family = A[9]
            yield Rpt(family, start, end, remain, strand)

    yield None

def open_out(file):
    """Open an .fa.outfile and return pointer to first entry"""
    fp = open(file)
    fp.readline()
    fp.readline()
    fp.readline()
    return fp

def family(line):
    """Given a .fa.out line, return start, stop, family name"""
    A = re.split("\s+", line.strip())
    return (A[9], A[5], A[6])

def read_families(real_file):
    return {family(line) for line in open_out(real_file)}


def compute_stats(chrLen, ToolGen, RealGen, FamHash, fp_dist = 10):
    """Assumption: Every two "real" intervals have a distance of at least 2*fp_dist (enforced by assertion"""
    t = next(ToolGen)
    r = next(RealGen)
    r_last = Rpt("X", -2*fp_dist, -2*fp_dist, -1, -1);
    FamHash[r.family][0] += len(r)  # 0 = total number base, 1 = # tp
    left_bound = 0

    bases_covered = len(r)             # Number of bases not covered
    fp = 0                            # Number of false positives
    fp_d = 0;             # Number of false positives within fp_dist of a true positive


    try:
        while r and t:
            if t.end < r.start or t.end < left_bound:
                fp += max(0, min(t.end, r.start) - max(t.start, left_bound)) 
                fp_d += max(0, min(t.end, r.start, r_last.end + fp_dist) - max(t.start, left_bound))
                fp_d += max(0, min(t.end, r.start) - max(t.start, left_bound, r.start - fp_dist))
                fp_d -= max(0, min(t.end, r.start, r_last.end + fp_dist) - max(t.start, left_bound, r.start - fp_dist));  # Remove Double counting
                left_bound = max(t.end, left_bound)
                t = next(ToolGen)
                if not t:
                    break
                continue
            if r.end < t.start or r.end < left_bound:
                r_last = r
                r = next(RealGen)
                if not r:
                    break

                bases_covered += len(r)
                FamHash[r.family][0] += len(r)
                continue

            # At this point: they must overlap.  (Note: could be that t overlaps with the next instance)
            start = max(left_bound, t.start, r.start)
            end = min(t.end, r.end)

            l = end - start
            FamHash[r.family][1] += max(l,0)

            if r.end <= t.end:
                fp += max(0, r.start - max(t.start, left_bound))
                fp_d += max(0, min(r.start, r_last.end + fp_dist) - max(t.start, left_bound))
                fp_d += max(0, r.start - max(t.start, left_bound, r.start - fp_dist))
                fp_d -= max(0, min(r.start, r_last.end + fp_dist) - max(t.start, left_bound, r.start - fp_dist))
                left_bound = max(r.end, left_bound)
                r_last = r
                r = next(RealGen)
                if not r:
                    break

                bases_covered += len(r)
                FamHash[r.family][0] += len(r)
            else:
                fp += max(0, min(t.end, r.start) - max(t.start, left_bound))
                fp_d += max(0, min(t.end, r.start, r_last.end + fp_dist) - max(t.start, left_bound))
                fp_d += max(0, min(t.end, r.start) - max(t.start, left_bound, r.start - fp_dist))
                fp_d -= max(0, min(t.end, r.start, r_last.end + fp_dist) - max(t.start, left_bound, r.start - fp_dist))
                left_bound = max(t.end, left_bound)
                t = next(ToolGen)
                if not t:
                    break
    except StopIteration:
        pass

    try:
        while r:
            r_last = r
            r = next(RealGen)
            if not r:
                break
            bases_covered += len(r)
            FamHash[r.family][0] += len(r)
    except StopIteration:
        pass

    try:
        while t:
            fp += max(0, t.end - max(t.start, left_bound))
            fp_d += max(0, min(t.end, r_last.end + fp_dist) - max(t.start, left_bound))
            t = next(ToolGen)
    except StopIteration:
        pass
            

    return [chrLen - bases_covered, fp, fp_d]

def print_stats(FamHash):
    K = sorted(FamHash.keys())
    for k in K:
        T = FamHash[k]
        print("{name} {TP} {TOTAL} {TPR:<5}".format(name = k, TP = T[1], TOTAL = T[0], TPR = (round(T[1] / T[0],3) if T[0] > 0 else -1)))


def collect_stats(real_out, tool_out, fp_dist = 10):
    """
    Parameters:
    * chrLen: chromosome length
    * real_out: .fa.out file for chromsome file
    * tool_out: .fa.out file produced by tool + repeat masker
    * fp_dist: Maximum distance of an false positive from a true positive to be counted seperately (see fp_d return value)
    Return values:
    * negatives: Number of bases not part of a TE (TP + FP)
    * fp: number false positives
    * fp_d: number of false positives within fp_dist of a true positive
    * FamHash: Mapping of family name to (#bases, #TP)
    """
    families = read_families(real_out)
    FamHash = {T[0]:[0,0] for T in families}  # FamId -> total, tp

    # Get chromosome length
    T = repeat_bounds_generator(tool_out)
    t = next(T)
    chrLen = t.remain + t.end

    ToolGen = repeat_bounds_generator(tool_out)
    RealGen = repeat_bounds_generator(real_out)

    #negatives, fp, fp_d = compute_stats(ToolGen, RealGen, FamHash, int(fp_dist))   # T[0]: Number of uncoverd bases
    negatives, fp, fp_d = compute_stats(chrLen, ToolGen, RealGen, FamHash, int(fp_dist))   # T[0]: Number of uncoverd bases
    TP = 0
    total = 0
    for f in FamHash:
        total += FamHash[f][0]
        TP += FamHash[f][1]

    return negatives, fp, fp_d, total, TP, FamHash

def main(real_out, tool_out, fp_dist = 10, print_fams = True):
    negatives, fp, fp_d, total, TP, FamHash = collect_stats(real_out, tool_out, fp_dist)

    if print_fams:
        print_stats(FamHash)
        print("------------------")
    print("Overall sensitivity: {} {} {}".format(TP, total, round(TP/float(total), 3)))
    print("Total uncovered bases: " + str(negatives))
    print("Total false positives: " + str(fp))
    print("Specificity: " + str(round(1 - fp/negatives, 3)))
    print("Total FPs within " + str(fp_dist) + " bases of a TE: " + str(fp_d) + ", " + ('NA' if fp == 0 else str(100*round(fp_d/fp, 3)) + "% of FPs"))


if __name__ == "__main__":
    main(*sys.argv[1:])

    
